# 替换表
### 定义
替换表就是根据一个表 `A` 创建一个新表 `B`, `B` 的行为和 `A` 完全一样, 后续对 `B` 的赋值和修改都不会影响 `A`.

### 使用场景
在日常写代码时, 经常会用到 `table.copy` 这个接口来拷贝一个表, 然后改变新表的几个字段, 再把这个表丢出去作为返回值给其他地方用.

一般来说, 拷贝一个表无非是要对某个表做修改, 又不想影响原始数据. 

但有时候可能原始表有100个字段, 而我们只要改几个字段, 这个时候拷贝表是非常浪费的.

这时就可以用替换表来解决这个问题。

```lua
local t1 = {
    1,2,3,
    a = "a",
    b = "b",
}

local t2 = table_replace(t1)

t2[1] = 11
t2.a = "aa"
```

这时不管是遍历 t2, 还是直接索引, t2 的表现都像是一个正常的表一样，
其值为:
```lua
t2 = {
    [1] = 11,
    [2] = 2,
    [3] = 3,
    ["a"] = "aa",
    ["b"] = "b",
}
```

生成替换表的代价就是生成一个很小的表（只含替换字段）和一个 _next 闭包，相比于表拷贝，
这点开销忽略不计，可以放心使用。

# 模拟程度
5.3 版的实现已经做到了完全模拟, 以下操作均正常:
* `table.insert`
* `#`
* `pairs`
* `ipairs`
* 索引值 `index`
* 赋值 `__newindex`

***

5.1 版由于不支持 `__pairs` 和 `__len` 元方法, 所以实现起来比较麻烦, 不但 pairs 要通过把数据存到元表里来才能实现, `#` 和 `table.insert` 更是无法实现.

# 文件说明
* `replace51.lua`, 5.1 版本的实现, 由于把数据存到元表里, 且改写了 pairs, 所以会降低系统的整体性能, 请谨慎使用. 如果真想用, 可以改写 Lua 代码, 让其支持 `__pairs` 即可.
* `replace53.lua`, 5.3 版本的实现, 5.4 当然也可以用
* `test.lua`, 测试文件

